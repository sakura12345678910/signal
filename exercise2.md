# 信号処理　プログラミング実習　第２回

## 目次
1. [GitHubの使い方](#githubの使い方)
1. [信号処理のプログラミング１](#信号処理のプログラミング１)


## GitHubの使い方
元々gitは複数人で開発を行うために作られたソフトウェアだが，
この講義ではあくまでも各人のファイルが失われないようにするための
バックアップとして利用する．（実体としてはGitHubのサーバ上に履歴情報が保存されているものであるため，
GitHubに障害が起きたら当然取り出せない）
ここではアカウントの作成からユーザー認証を経由し，GitHub上への履歴情報の登録，
登録した履歴情報の回収を行う．

### GitHubアカウントの作成
ここではGitHubのアカウントを作成します．
[GitHub](https://github.com)にアクセスし，右上の"Sign up"を選択．
メールアドレスを入力し，パスワードを設定，ユーザー名を決めてください．
ロボットでないことを検証するテストを終えると，メールが送られてきて，そのコードを入力します．
この時点でアカウントが作成され，ログイン画面に移ります．
先に設定したユーザー名またはメールアドレスとパスワードを使ってログインしてください．

適当なアンケートのあと，プランの選択があります．freeプランで十分です．
(学生なら無料でより有料版の一部機能が使えたと思います．)
"Continue to free"を選択して，左上に"Dashboard"と書かれた画面に来れば成功です．

### GitHubとの通信．ユーザー認証の設定
GitHubにSSH公開鍵認証を通じてアクセスする．
まず公開鍵と秘密鍵のペアを作成する．
これは`ssh-keygen`コマンドで行う．
入力するとどこに鍵を保存するかを決められる．デフォルトでは
`C:\Users\<username>\.ssh\id_<暗号化方式>`になる．
保存先はどこでもいいがデフォルトのままでもよい．
その後パスフレーズを指定する．
（パスワードみたいなもの．空行を設定できるのでそのままエンターを押してもいいが，セキュリティ上は好ましくない）
二回同じパスフレーズを入力できたら，鍵のペアを作ってくれる．
先に指定されたフォルダを見に行けば，`id_<暗号化方式>, id_<暗号化方式>.pub`という二つのファイルが作成されている．
.pubとついているほうが公開鍵である．

GitHubのログイン後のページにアクセスし，右上のアイコンをクリックし，Settingsに移動する．
左側に"SSH and GPG keys"という欄があるので，そこをクリックし，
右上の"New SSH key"をクリックし，公開鍵の登録を行う．
タイトルには適当に鍵の名前を付けておく．複数の計算機を利用する場合，どこにある鍵なのかを明示するために使える．
タイトルなしでも設定できる．
公開鍵の中身をコピペしてKeyの欄に貼り付け，"Add SSH key"を押すと登録される．
そのアカウントのメールアドレスにSSHキーが登録されたという確認のメールが来ていればOK.

最後にSSHアクセスを行う．ターミナルで
`ssh -T git@github.com`
を実行して，ユーザー名を含むメッセージが表示されたらOK.
（GitHubはアカウントに登録された公開鍵からユーザーを判別している．
同じ鍵を複数のアカウントに登録すると，意図していないアカウントと判断されることがあるので注意．）

### リモートリポジトリを作成し，情報の登録
再びGitHubのダッシュボードのページに移動し，左上の"Create repository"というのを選択する．
リポジトリの名前を決める．これは基本的にはプロジェクトの名前だと思ってよい．
フォルダに着けている名前と共通化しておくほうがいいと思う．
Descriptionはリポジトリの簡単な説明だが，入力しなくてもいい．
publicかprivateか選択できるが，説明通りpublicは全世界的に公開されることになる．
つまり誰でも見ることができる状態になる．逆にprivateだと指定されたユーザー以外はリポジトリを見つけることができない．
機密性の高い情報を扱うならprivateにするほうがよい．
あとはREADME.mdを追加してくれたり，.gitignore, ライセンスファイルをテンプレートから作ってくれるが，別になくてもいい．
"Create repository"を押せば，リモートリポジトリが作成される．

作成されたばかりのリモートリポジトリには何の情報も入っていない．
最初の画面ではセットアップ方法が書かれているので，これに従えばよい．
今回は先にローカルリポジトリがあるので，下側の"push an existing repository from the command line"に従えばよい．
最初にHTTPSではなく，SSHに変更しておく．
その後，
```
git remote add origin git@github.com:<username>/<repository name>.git
git branch -M main
git push -u origin main
```
と３つのコマンドを実行する．
（このときSSHキーをデフォルト以外の場所に作っていた場合，そのキーがわからずアクセスできない．
この場合`$env:GIT_SSH_COMMAND="ssh -i <path to ssh key>`として，
git内で利用されるsshコマンドにキーの指定を加えておけばよい．）
最初のコマンドでリモートリポジトリをローカルリポジトリに教えて，
最後にリモートリポジトリに情報を送っている．
（途中のコマンドはブランチの名前の変更．デフォルトだとmasterになっているが，mainに変更している）

コマンドを入力し終えたら，GitHub上のページを再読み込みする．
すると自分のフォルダの内容がGitHubのページ上に表示されている．クリックすればその中身も表示される．
またターミナル上で`git branch -a`と入力すると，全てのブランチが表示される．
このとき緑色でアスタリスクがついているのがローカルにある今見ているブランチであり，
赤色になっているのがリモートにあるリポジトリである．

### リモートリポジトリからのクローン
ここまでできたら，一度ローカルのリポジトリを削除してリモートリポジトリから復元できるか確認してみる．
まずは`git status`を確認し，特に変更がされていないことを確認する．
また`git log`も実行し，HEAD->mainとorigin/mainが同じコミットを指していることを確認しておく．
これらが確認出来たら，エクスプローラからそのフォルダを削除する．
これでローカルではデータが失われたことになる（Windowsだとごみ箱から復元できたりするが）

リモートリポジトリをブラウザで開き，右上の"<> Code"というところをクリックする．ZIPでもダウンロードできるが，今回はSSHのURLをコピーする．

`git clone <コピーしたURL>`を実行する．
するとリモートリポジトリの名前のフォルダが作成され，その中には
リモートリポジトリに登録したすべてのファイルが出てくる．
ここで`git status`や`git log`を実行すると，破壊する前と同じ状態に戻っている．

今回は仮想環境を破壊しているので，この部分はもう一度元に戻す必要がある．`uv sync --frozen`でuv.lockファイルを通じて仮想環境を再び作成できる．


### 余談
細かいことを言えば，gitは分散型バージョン管理システムということで，
履歴の情報が中央集権的なサーバ上にあるのではなく，各人がそれぞれ履歴情報を持つことができるというところにその特徴がある．
これによって中央のサーバに障害が起きてもそれぞれの履歴を寄せ集めれば復旧できるという障害耐性が見込まれる．
この点が分散型バージョン管理システムのメリットだが，個人で開発するうえではあまり関係ない．

またgitは履歴を保存するという話をしたが，
複数人で開発する場合（多くの企業では複数人で開発を行う），
保存された履歴をどうやって共有するかという問題が残る．
またそれぞれの進捗によって履歴がずれていく．
ある人（A)がコードを変更している間に他の人（B)はまた別の場所を変更している．
するとAの手元の履歴にはBの変更履歴が含まれない．
またBの変更とAの変更が同じ場所であった場合，矛盾が生じる．
こうした矛盾はコンフリクトと呼ばれる．これを解決する手段は提供されているがこの授業では扱わない．

## 信号処理のプログラミング１

### 信号の可視化，グラフ図示
以下のコードを例に信号のグラフ表示を行う．
注意点としては，
- 定義した関数がndarrayを受けられるように`np.vectorize()`をしている．
- Pythonにおいて複素数は`j`という文字を使って表示される．変数名特別するために直前に数字が入っている場合は虚数単位として扱われる．

これを適当にアレンジして，いろんな信号を図示してみる．

```python
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

PI = np.pi
t = np.linspace(-2*PI, 2 * PI, 1000)

def rect(t, min, max):
    if min <= t and t <= max:
        return 1
    else:
        return 0

nprect = np.vectorize(rect)

z = np.exp(1j * t * nprect(t, -PI, PI))
fig = plt.figure()

x1 = z.real
ax1 = fig.add_subplot(2, 1, 1)
ax1.plot(t, x1)

x2 = z.imag
ax2 = fig.add_subplot(2, 1, 2)
ax2.plot(t, x2)

plt.show()
```

### フーリエ級数による表示
以下のコードで矩形波とそのフーリエ級数を図示してみる．
また級数の項を一つずつ増やしたときの結果確認し，
低周波の項だけの場合と，高周波だけの場合の項を比較してみる．
また項数を増やしても，誤差の大きい場所がある．このコードをアレンジして，信号とフーリエ級数表示の誤差を図示してみる．
```python
import numpy as np
import matplotlib.pyplot as plt

PI = np.pi

# 矩形波の立ち上がるところだけの信号
def clk(t):
    if t >= 0:
        return 1
    else:
        return -1

# np.linspaceで用意したndarrayを引数にできるようにベクトル化
npclk = np.vectorize(clk)

# フーリエ級数の部分和（途中で打ち切ったもの）
# これはnp.sin()関数に使われるためndarrayを引数にでき，ベクトル化しなくてよい
def partialsum(t, n):
    sum = 0
    for i in range(1, n+1):
        sum += (4 / PI) * np.sin((2 * i-1)*t) / (2 * i - 1)
    return sum

t = np.linspace(-PI, PI, 1000)

plt.plot(t, npclk(t))
plt.plot(t, partialsum(t, 5))
plt.show()
```
